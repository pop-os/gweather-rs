// Generated by gir (https://github.com/gtk-rs/gir @ 350409c)
// from 
// from gir-files (./gir-files @ 38b7451)
// DO NOT EDIT

use glib::translate::*;
#[cfg(any(feature = "v3_12", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
use std::boxed::Box as Box_;
use std::mem;

glib::wrapper! {
    #[derive(Debug, PartialOrd, Ord, Hash)]
    pub struct Location(Shared<ffi::GWeatherLocation>);

    match fn {
        ref => |ptr| ffi::gweather_location_ref(ptr),
        unref => |ptr| ffi::gweather_location_unref(ptr),
        type_ => || ffi::gweather_location_get_type(),
    }
}

impl Location {
    #[doc(alias = "gweather_location_new_detached")]
    pub fn new_detached(name: &str, icao: Option<&str>, latitude: f64, longitude: f64) -> Location {
        unsafe {
            from_glib_full(ffi::gweather_location_new_detached(name.to_glib_none().0, icao.to_glib_none().0, latitude, longitude))
        }
    }

    //#[doc(alias = "gweather_location_deserialize")]
    //pub fn deserialize(&self, serialized: /*Ignored*/&glib::Variant) -> Option<Location> {
    //    unsafe { TODO: call ffi:gweather_location_deserialize() }
    //}

    //#[cfg(any(feature = "v3_12", feature = "dox"))]
    //#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    //#[doc(alias = "gweather_location_detect_nearest_city")]
    //pub fn detect_nearest_city<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, lat: f64, lon: f64, cancellable: /*Ignored*/Option<&gio::Cancellable>, callback: P) {
    //    unsafe { TODO: call ffi:gweather_location_detect_nearest_city() }
    //}

    #[doc(alias = "gweather_location_equal")]
    fn equal(&self, two: &Location) -> bool {
        unsafe {
            from_glib(ffi::gweather_location_equal(self.to_glib_none().0, two.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_find_by_country_code")]
    pub fn find_by_country_code(&self, country_code: &str) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_find_by_country_code(self.to_glib_none().0, country_code.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_find_by_station_code")]
    pub fn find_by_station_code(&self, station_code: &str) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_find_by_station_code(self.to_glib_none().0, station_code.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v3_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    #[doc(alias = "gweather_location_find_nearest_city")]
    pub fn find_nearest_city(&self, lat: f64, lon: f64) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_find_nearest_city(self.to_glib_none().0, lat, lon))
        }
    }

    #[cfg(any(feature = "v3_12", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_12")))]
    #[doc(alias = "gweather_location_find_nearest_city_full")]
    pub fn find_nearest_city_full(&self, lat: f64, lon: f64, func: Option<Box_<dyn Fn(&Location) -> bool + 'static>>) -> Option<Location> {
        let func_data: Box_<Option<Box_<dyn Fn(&Location) -> bool + 'static>>> = Box_::new(func);
        unsafe extern "C" fn func_func(location: *mut ffi::GWeatherLocation, user_data: glib::ffi::gpointer) -> glib::ffi::gboolean {
            let location = from_glib_borrow(location);
            let callback: &Option<Box_<dyn Fn(&Location) -> bool + 'static>> = &*(user_data as *mut _);
            let res = if let Some(ref callback) = *callback {
                callback(&location)
            } else {
                panic!("cannot get closure...")
            };
            res.into_glib()
        }
        let func = if func_data.is_some() { Some(func_func as _) } else { None };
        unsafe extern "C" fn destroy_func(data: glib::ffi::gpointer) {
            let _callback: Box_<Option<Box_<dyn Fn(&Location) -> bool + 'static>>> = Box_::from_raw(data as *mut _);
        }
        let destroy_call5 = Some(destroy_func as _);
        let super_callback0: Box_<Option<Box_<dyn Fn(&Location) -> bool + 'static>>> = func_data;
        unsafe {
            from_glib_full(ffi::gweather_location_find_nearest_city_full(self.to_glib_none().0, lat, lon, func, Box_::into_raw(super_callback0) as *mut _, destroy_call5))
        }
    }

    //#[doc(alias = "gweather_location_free_timezones")]
    //pub fn free_timezones(&self, zones: /*Ignored*/&Timezone) {
    //    unsafe { TODO: call ffi:gweather_location_free_timezones() }
    //}

    #[cfg_attr(feature = "v40_0", deprecated = "Since 40.0")]
    #[doc(alias = "gweather_location_get_children")]
    #[doc(alias = "get_children")]
    pub fn children(&self) -> Vec<Location> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::gweather_location_get_children(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_city_name")]
    #[doc(alias = "get_city_name")]
    pub fn city_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_city_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_code")]
    #[doc(alias = "get_code")]
    pub fn code(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_code(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_coords")]
    #[doc(alias = "get_coords")]
    pub fn coords(&self) -> (f64, f64) {
        unsafe {
            let mut latitude = mem::MaybeUninit::uninit();
            let mut longitude = mem::MaybeUninit::uninit();
            ffi::gweather_location_get_coords(self.to_glib_none().0, latitude.as_mut_ptr(), longitude.as_mut_ptr());
            let latitude = latitude.assume_init();
            let longitude = longitude.assume_init();
            (latitude, longitude)
        }
    }

    #[doc(alias = "gweather_location_get_country")]
    #[doc(alias = "get_country")]
    pub fn country(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_country(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_country_name")]
    #[doc(alias = "get_country_name")]
    pub fn country_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_country_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_distance")]
    #[doc(alias = "get_distance")]
    pub fn distance(&self, loc2: &Location) -> f64 {
        unsafe {
            ffi::gweather_location_get_distance(self.to_glib_none().0, loc2.to_glib_none().0)
        }
    }

    #[cfg(any(feature = "v3_36", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_36")))]
    #[doc(alias = "gweather_location_get_english_name")]
    #[doc(alias = "get_english_name")]
    pub fn english_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_english_name(self.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v3_38", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_38")))]
    #[doc(alias = "gweather_location_get_english_sort_name")]
    #[doc(alias = "get_english_sort_name")]
    pub fn english_sort_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_english_sort_name(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gweather_location_get_level")]
    //#[doc(alias = "get_level")]
    //pub fn level(&self) -> /*Ignored*/LocationLevel {
    //    unsafe { TODO: call ffi:gweather_location_get_level() }
    //}

    #[doc(alias = "gweather_location_get_name")]
    #[doc(alias = "get_name")]
    pub fn name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_parent")]
    #[doc(alias = "get_parent")]
    pub fn parent(&self) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_parent(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gweather_location_get_sort_name")]
    #[doc(alias = "get_sort_name")]
    pub fn sort_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_sort_name(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gweather_location_get_timezone")]
    //#[doc(alias = "get_timezone")]
    //pub fn timezone(&self) -> /*Ignored*/Option<Timezone> {
    //    unsafe { TODO: call ffi:gweather_location_get_timezone() }
    //}

    #[doc(alias = "gweather_location_get_timezone_str")]
    #[doc(alias = "get_timezone_str")]
    pub fn timezone_str(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gweather_location_get_timezone_str(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gweather_location_get_timezones")]
    //#[doc(alias = "get_timezones")]
    //pub fn timezones(&self) -> /*Ignored*/Vec<Timezone> {
    //    unsafe { TODO: call ffi:gweather_location_get_timezones() }
    //}

    #[doc(alias = "gweather_location_has_coords")]
    pub fn has_coords(&self) -> bool {
        unsafe {
            from_glib(ffi::gweather_location_has_coords(self.to_glib_none().0))
        }
    }

    #[cfg(any(feature = "v40", feature = "dox"))]
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v40")))]
    #[doc(alias = "gweather_location_next_child")]
    pub fn next_child(&self, child: Option<&Location>) -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_next_child(self.to_glib_none().0, child.to_glib_full()))
        }
    }

    //#[doc(alias = "gweather_location_serialize")]
    //pub fn serialize(&self) -> /*Ignored*/Option<glib::Variant> {
    //    unsafe { TODO: call ffi:gweather_location_serialize() }
    //}

    #[doc(alias = "gweather_location_get_world")]
    #[doc(alias = "get_world")]
    pub fn world() -> Option<Location> {
        unsafe {
            from_glib_full(ffi::gweather_location_get_world())
        }
    }
}

impl PartialEq for Location {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.equal(other)
    }
}

impl Eq for Location {}
